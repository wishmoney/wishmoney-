{
  "file": "blockchain-explorer.json",
  "description": "Adds json rpc methods for block and transaction actions",
  "required": [
    "core/bytecoin.json"
  ],
  "files": [

    {
      "path": "/src/Daemon/Daemon.cpp",
      "changes": [
        {
          "action": "add_above",
          "marker": "arg_testnet_on  = {\"testnet\"",
          "parameters": {
            "text": [
              "  const command_line::arg_descriptor<bool> arg_blockexplorer_on = {\"enable-blockexplorer\", \"Enable blockchain explorer RPC\", false};"
            ]
          }
        },
        {
          "action": "add_below",
          "marker": "command_line::add_arg(desc_cmd_sett, arg_testnet_on);",
          "parameters": {
            "text": [
              "    command_line::add_arg(desc_cmd_sett, arg_blockexplorer_on);"
            ]
          }
        },
        {
          "action": "add_below",
          "marker": "CryptoNote::CurrencyBuilder currencyBuilder(logManager);",
          "parameters": {
            "text": [
              "bool blockexplorer_mode = command_line::get_arg(vm, arg_blockexplorer_on);",
              "currencyBuilder.isBlockexplorer(blockexplorer_mode);"
            ]
          }
        }
      ]
    },

    {
      "path": "/src/CryptoNoteCore/Currency.h",
      "changes": [
        {
          "action": "add_above",
          "marker": "bool isTestnet() const { return m_testnet; }",
          "parameters": {
            "text": [
              "  bool isBlockexplorer() const { return m_isBlockexplorer; }"
            ]
          }
        },
        {
          "action": "add_above",
          "marker": "CurrencyBuilder& testnet(bool val) { m_currency.m_testnet = val; return *this; }",
          "parameters": {
            "text": [
              "  CurrencyBuilder& isBlockexplorer(const bool val) { m_currency.m_isBlockexplorer = val; return *this; }"
            ]
          }
        },
        {
          "action": "add_below",
          "marker": "bool m_testnet;",
          "parameters": {
            "text": [
              "  bool m_isBlockexplorer;"
            ]
          }
        }
      ]
    },

    {
      "path": "/src/CryptoNoteCore/Currency.cpp",
      "changes": [
        {
          "action": "add_above",
          "marker": "testnet(false);",
          "parameters": {
            "text": [
              "    isBlockexplorer(false);"
            ]
          }
        },
        {
          "action": "add_below",
          "marker": "m_blockGrantedFullRewardZone(currency.m_blockGrantedFullRewardZone),",
          "parameters": {
            "text": [
              "m_isBlockexplorer(currency.m_isBlockexplorer),"
            ]
          }
        }
      ]
    },

    {
      "path": "/src/Rpc/CoreRpcServerCommandsDefinitions.h",
      "changes": [
        {
          "action": "add_above",
          "marker": "struct COMMAND_RPC_GET_LAST_BLOCK_HEADER {",
          "parameters": {
            "text": [
              "struct f_transaction_short_response {",
              "  std::string hash;",
              "  uint64_t fee;",
              "  uint64_t amount_out;",
              "  uint64_t size;",
              "",
              "  void serialize(ISerializer &s) {",
              "    KV_MEMBER(hash)",
              "    KV_MEMBER(fee)",
              "    KV_MEMBER(amount_out)",
              "    KV_MEMBER(size)",
              "  }",
              "};",
              "",
              "struct f_transaction_details_response {",
              "  std::string hash;",
              "  size_t size;",
              "  std::string paymentId;",
              "  uint64_t mixin;",
              "  uint64_t fee;",
              "  uint64_t amount_out;",
              "",
              "  void serialize(ISerializer &s) {",
              "    KV_MEMBER(hash)",
              "    KV_MEMBER(size)",
              "    KV_MEMBER(paymentId)",
              "    KV_MEMBER(mixin)",
              "    KV_MEMBER(fee)",
              "    KV_MEMBER(amount_out)",
              "  }",
              "};",
              "",
              "struct f_block_short_response {",
              "  uint64_t timestamp;",
              "  uint32_t height;",
              "  std::string hash;",
              "  uint64_t tx_count;",
              "  uint64_t cumul_size;",
              "",
              "  void serialize(ISerializer &s) {",
              "    KV_MEMBER(timestamp)",
              "    KV_MEMBER(height)",
              "    KV_MEMBER(hash)",
              "    KV_MEMBER(cumul_size)",
              "    KV_MEMBER(tx_count)",
              "  }",
              "};",
              "",
              "struct f_block_details_response {",
              "  uint8_t major_version;",
              "  uint8_t minor_version;  ",
              "  uint64_t timestamp;",
              "  std::string prev_hash;",
              "  uint32_t nonce;",
              "  bool orphan_status;",
              "  uint32_t height;",
              "  uint64_t depth;",
              "  std::string hash;",
              "  uint64_t difficulty;",
              "  uint64_t reward;",
              "  uint64_t blockSize;",
              "  size_t sizeMedian;",
              "  uint64_t effectiveSizeMedian;",
              "  uint64_t transactionsCumulativeSize;",
              "  std::string alreadyGeneratedCoins;",
              "  uint64_t alreadyGeneratedTransactions;",
              "  uint64_t baseReward;",
              "  double penalty;",
              "  uint64_t totalFeeAmount;",
              "  std::vector<f_transaction_short_response> transactions;",
              "",
              "  void serialize(ISerializer &s) {",
              "    KV_MEMBER(major_version)",
              "    KV_MEMBER(minor_version)",
              "    KV_MEMBER(timestamp)",
              "    KV_MEMBER(prev_hash)",
              "    KV_MEMBER(nonce)",
              "    KV_MEMBER(orphan_status)",
              "    KV_MEMBER(height)",
              "    KV_MEMBER(depth)",
              "    KV_MEMBER(hash)",
              "    KV_MEMBER(difficulty)",
              "    KV_MEMBER(reward)",
              "    KV_MEMBER(blockSize)",
              "    KV_MEMBER(sizeMedian)",
              "    KV_MEMBER(effectiveSizeMedian)",
              "    KV_MEMBER(transactionsCumulativeSize)",
              "    KV_MEMBER(alreadyGeneratedCoins)",
              "    KV_MEMBER(alreadyGeneratedTransactions)",
              "    KV_MEMBER(baseReward)",
              "    KV_MEMBER(penalty)",
              "    KV_MEMBER(transactions)",
              "    KV_MEMBER(totalFeeAmount)",
              "  }",
              "};"
            ]
          }
        },
        {
          "action": "add_above",
          "marker": "struct COMMAND_RPC_QUERY_BLOCKS {",
          "parameters": {
            "text": [
              "struct F_COMMAND_RPC_GET_BLOCKS_LIST {",
              "  struct request {",
              "    uint64_t height;",
              "",
              "    void serialize(ISerializer &s) {",
              "      KV_MEMBER(height)",
              "    }",
              "  };",
              "",
              "  struct response {",
              "    std::vector<f_block_short_response> blocks; //transactions blobs as hex",
              "    std::string status;",
              "",
              "    void serialize(ISerializer &s) {",
              "      KV_MEMBER(blocks)",
              "      KV_MEMBER(status)",
              "    }",
              "  };",
              "};",
              "",
              "struct F_COMMAND_RPC_GET_BLOCK_DETAILS {",
              "  struct request {",
              "    std::string hash;",
              "",
              "    void serialize(ISerializer &s) {",
              "      KV_MEMBER(hash)",
              "    }",
              "  };",
              "",
              "  struct response {",
              "    f_block_details_response block;",
              "    std::string status;",
              "",
              "    void serialize(ISerializer &s) {",
              "      KV_MEMBER(block)",
              "      KV_MEMBER(status)",
              "    }",
              "  };",
              "};",
              "",
              "struct F_COMMAND_RPC_GET_TRANSACTION_DETAILS {",
              "  struct request {",
              "    std::string hash;",
              "",
              "    void serialize(ISerializer &s) {",
              "      KV_MEMBER(hash)",
              "    }",
              "  };",
              "",
              "  struct response {",
              "    Transaction tx;",
              "    f_transaction_details_response txDetails;",
              "    f_block_short_response block;",
              "    std::string status;",
              "",
              "    void serialize(ISerializer &s) {",
              "      KV_MEMBER(tx)",
              "      KV_MEMBER(txDetails)",
              "      KV_MEMBER(block)",
              "      KV_MEMBER(status)",
              "    }",
              "  };",
              "};",
              "",
              "struct F_COMMAND_RPC_GET_POOL {",
              "  typedef EMPTY_STRUCT request;",
              "",
              "  struct response {",
              "    std::vector<f_transaction_short_response> transactions; //transactions blobs as hex",
              "    std::string status;",
              "",
              "    void serialize(ISerializer &s) {",
              "      KV_MEMBER(transactions)",
              "      KV_MEMBER(status)",
              "    }",
              "  };",
              "};"
            ]
          }
        }
      ]
    },
    {
      "path": "/src/Rpc/RpcServer.h",
      "changes": [
        {
          "action": "add_above",
          "marker": "#include \"CoreRpcServerCommandsDefinitions.h\"",
          "parameters": {
            "text": [
              "#include \"Common/Math.h\""
            ]
          }
        },
        {
          "action": "add_above",
          "marker": "Logging::LoggerRef logger;",
          "parameters": {
            "text": [
              "  bool f_on_blocks_list_json(const F_COMMAND_RPC_GET_BLOCKS_LIST::request& req, F_COMMAND_RPC_GET_BLOCKS_LIST::response& res);",
              "  bool f_on_block_json(const F_COMMAND_RPC_GET_BLOCK_DETAILS::request& req, F_COMMAND_RPC_GET_BLOCK_DETAILS::response& res);",
              "  bool f_on_transaction_json(const F_COMMAND_RPC_GET_TRANSACTION_DETAILS::request& req, F_COMMAND_RPC_GET_TRANSACTION_DETAILS::response& res);",
              "  bool f_on_transactions_pool_json(const F_COMMAND_RPC_GET_POOL::request& req, F_COMMAND_RPC_GET_POOL::response& res);",
              "  bool f_getMixin(const Transaction& transaction, uint64_t& mixin);"
            ]
          }
        }
      ]
    },
    {
      "path": "/src/Rpc/RpcServer.cpp",
      "changes": [
        {
          "action": "add_above",
          "marker": "{ \"getblockcount\", { makeMemberMethod(&RpcServer::on_getblockcount), true } },",
          "parameters": {
            "text": [
              "      { \"f_blocks_list_json\", { makeMemberMethod(&RpcServer::f_on_blocks_list_json), false } },",
              "      { \"f_block_json\", { makeMemberMethod(&RpcServer::f_on_block_json), false } },",
              "      { \"f_transaction_json\", { makeMemberMethod(&RpcServer::f_on_transaction_json), false } },",
              "      { \"f_on_transactions_pool_json\", { makeMemberMethod(&RpcServer::f_on_transactions_pool_json), false } },"
            ]
          }
        },
        {
          "action": "add_above",
          "marker": "bool RpcServer::on_getblockcount(const COMMAND_RPC_GETBLOCKCOUNT::request& req, COMMAND_RPC_GETBLOCKCOUNT::response& res) {",
          "parameters": {
            "text": [
              "bool RpcServer::f_on_blocks_list_json(const F_COMMAND_RPC_GET_BLOCKS_LIST::request& req, F_COMMAND_RPC_GET_BLOCKS_LIST::response& res) {",
              "  // check if blockchain explorer RPC is enabled",
              "  if (m_core.getCurrency().isBlockexplorer() == false) {",
              "    return false;",
              "  }",
              "",
              "  if (m_core.getTopBlockIndex() + 1 <= req.height) {",
              "    throw JsonRpc::JsonRpcError{ CORE_RPC_ERROR_CODE_TOO_BIG_HEIGHT,",
              "      std::string(\"To big height: \") + std::to_string(req.height) + \", current blockchain height = \" + std::to_string(m_core.getTopBlockIndex() + 1) };",
              "  }",
              "",
              "  uint32_t print_blocks_count = 30;",
              "  uint32_t last_height = req.height - print_blocks_count;",
              "  if (req.height <= print_blocks_count)  {",
              "    last_height = 0;",
              "  } ",
              "",
              "  for (uint32_t i = req.height; i >= last_height; i--) {",
              "    Hash block_hash = m_core.getBlockHashByIndex(static_cast<uint32_t>(i));",
              "    if (!m_core.hasBlock(block_hash)) {",
              "      throw JsonRpc::JsonRpcError{",
              "        CORE_RPC_ERROR_CODE_INTERNAL_ERROR,",
              "        \"Internal error: can't get block by height. Height = \" + std::to_string(i) + '.' };",
              "    }",
              "    BlockTemplate blk = m_core.getBlockByHash(block_hash);",
              "    BlockDetails blkDetails = m_core.getBlockDetails(block_hash);",
              "",
              "    f_block_short_response block_short;",
              "    block_short.cumul_size = blkDetails.blockSize;",
              "    block_short.timestamp = blk.timestamp;",
              "    block_short.height = i;",
              "    block_short.hash = Common::podToHex(block_hash);",
              "    block_short.tx_count = blk.transactionHashes.size() + 1;",
              "",
              "    res.blocks.push_back(block_short);",
              "",
              "    if (i == 0)",
              "      break;",
              "  }",
              "",
              "  res.status = CORE_RPC_STATUS_OK;",
              "  return true;",
              "}",
              "",
              "bool RpcServer::f_on_block_json(const F_COMMAND_RPC_GET_BLOCK_DETAILS::request& req, F_COMMAND_RPC_GET_BLOCK_DETAILS::response& res) {",
              "  // check if blockchain explorer RPC is enabled",
              "  if (m_core.getCurrency().isBlockexplorer() == false) {",
              "    return false;",
              "  }",
              "",
              "  Hash hash;",
              "",
              "  try {",
              "    uint32_t height = boost::lexical_cast<uint32_t>(req.hash);",
              "    hash = m_core.getBlockHashByIndex(height);",
              "  } catch (boost::bad_lexical_cast &) {",
              "    if (!parse_hash256(req.hash, hash)) {",
              "      throw JsonRpc::JsonRpcError{",
              "        CORE_RPC_ERROR_CODE_WRONG_PARAM,",
              "        \"Failed to parse hex representation of block hash. Hex = \" + req.hash + '.' };",
              "    }",
              "  }",
              "",
              "  if (!m_core.hasBlock(hash)) {",
              "    throw JsonRpc::JsonRpcError{",
              "      CORE_RPC_ERROR_CODE_INTERNAL_ERROR,",
              "      \"Internal error: can't get block by hash. Hash = \" + req.hash + '.' };",
              "  }",
              "  BlockTemplate blk = m_core.getBlockByHash(hash);",
              "  BlockDetails blkDetails = m_core.getBlockDetails(hash);",
              "",
              "  if (blk.baseTransaction.inputs.front().type() != typeid(BaseInput)) {",
              "    throw JsonRpc::JsonRpcError{",
              "      CORE_RPC_ERROR_CODE_INTERNAL_ERROR,",
              "      \"Internal error: coinbase transaction in the block has the wrong type\" };",
              "  }",
              "",
              "  block_header_response block_header;",
              "  res.block.height = boost::get<BaseInput>(blk.baseTransaction.inputs.front()).blockIndex;",
              "  fill_block_header_response(blk, false, res.block.height, hash, block_header);",
              "",
              "  res.block.major_version = block_header.major_version;",
              "  res.block.minor_version = block_header.minor_version;",
              "  res.block.timestamp = block_header.timestamp;",
              "  res.block.prev_hash = block_header.prev_hash;",
              "  res.block.nonce = block_header.nonce;",
              "  res.block.hash = Common::podToHex(hash);",
              "  res.block.depth = m_core.getTopBlockIndex() - res.block.height;",
              "  res.block.difficulty = m_core.getBlockDifficulty(res.block.height);",
              "  res.block.transactionsCumulativeSize = blkDetails.transactionsCumulativeSize;",
              "  res.block.alreadyGeneratedCoins = std::to_string(blkDetails.alreadyGeneratedCoins);",
              "  res.block.alreadyGeneratedTransactions = blkDetails.alreadyGeneratedTransactions;",
              "  res.block.reward = block_header.reward;",
              "  res.block.sizeMedian = blkDetails.sizeMedian;",
              "  res.block.blockSize = blkDetails.blockSize;",
              "  res.block.orphan_status = blkDetails.isAlternative;",
              "",
              "  uint64_t maxReward = 0;",
              "  uint64_t currentReward = 0;",
              "  int64_t emissionChange = 0;",
              "  size_t blockGrantedFullRewardZone = m_core.getCurrency().blockGrantedFullRewardZoneByBlockVersion(block_header.major_version);",
              "  res.block.effectiveSizeMedian = std::max(res.block.sizeMedian, blockGrantedFullRewardZone);",
              "",
              "  res.block.baseReward = blkDetails.baseReward;",
              "  res.block.penalty = blkDetails.penalty;",
              "",
              "  // Base transaction adding",
              "  f_transaction_short_response transaction_short;",
              "  transaction_short.hash = Common::podToHex(getObjectHash(blk.baseTransaction));",
              "  transaction_short.fee = 0;",
              "  transaction_short.amount_out = getOutputAmount(blk.baseTransaction);",
              "  transaction_short.size = getObjectBinarySize(blk.baseTransaction);",
              "  res.block.transactions.push_back(transaction_short);",
              "",
              "  std::vector<Crypto::Hash> missed_txs;",
              "  std::vector<BinaryArray> txs;",
              "  m_core.getTransactions(blk.transactionHashes, txs, missed_txs);",
              "",
              "  res.block.totalFeeAmount = 0;",
              "",
              "  for (const BinaryArray& ba : txs) {",
              "    Transaction tx;",
              "    if (!fromBinaryArray(tx, ba)) {",
              "      throw std::runtime_error(\"Couldn't deserialize transaction\");",
              "    }",
              "    f_transaction_short_response transaction_short;",
              "    uint64_t amount_in = getInputAmount(tx);",
              "    uint64_t amount_out = getOutputAmount(tx);",
              "",
              "    transaction_short.hash = Common::podToHex(getObjectHash(tx));",
              "    transaction_short.fee = amount_in - amount_out;",
              "    transaction_short.amount_out = amount_out;",
              "    transaction_short.size = getObjectBinarySize(tx);",
              "    res.block.transactions.push_back(transaction_short);",
              "",
              "    res.block.totalFeeAmount += transaction_short.fee;",
              "  }",
              "",
              "  res.status = CORE_RPC_STATUS_OK;",
              "  return true;",
              "}",
              "",

              "bool RpcServer::f_on_transaction_json(const F_COMMAND_RPC_GET_TRANSACTION_DETAILS::request& req, F_COMMAND_RPC_GET_TRANSACTION_DETAILS::response& res) {",
              "  // check if blockchain explorer RPC is enabled",
              "  if (m_core.getCurrency().isBlockexplorer() == false) {",
              "    return false;",
              "  }",
              "",
              "  Hash hash;",
              "",
              "  if (!parse_hash256(req.hash, hash)) {",
              "    throw JsonRpc::JsonRpcError{",
              "      CORE_RPC_ERROR_CODE_WRONG_PARAM,",
              "      \"Failed to parse hex representation of transaction hash. Hex = \" + req.hash + '.' };",
              "  }",
              "",
              "  std::vector<Crypto::Hash> tx_ids;",
              "  tx_ids.push_back(hash);",
              "",
              "  std::vector<Crypto::Hash> missed_txs;",
              "  std::vector<BinaryArray> txs;",
              "  m_core.getTransactions(tx_ids, txs, missed_txs);",
              "",
              "  if (1 == txs.size()) {",
              "    Transaction transaction;",
              "    if (!fromBinaryArray(transaction, txs.front())) {",
              "      throw std::runtime_error(\"Couldn't deserialize transaction\");",
              "    }",
              "    res.tx = transaction;",
              "  } else {",
              "    throw JsonRpc::JsonRpcError{",
              "      CORE_RPC_ERROR_CODE_WRONG_PARAM,",
              "      \"transaction wasn't found. Hash = \" + req.hash + '.' };",
              "  }",
              "  TransactionDetails transactionDetails = m_core.getTransactionDetails(hash);",
              "",
              "  Crypto::Hash blockHash;",
              "  if (transactionDetails.inBlockchain) {",
              "    uint32_t blockHeight = transactionDetails.blockIndex;",
              "    if (!blockHeight) {",
              "      throw JsonRpc::JsonRpcError{",
              "        CORE_RPC_ERROR_CODE_INTERNAL_ERROR,",
              "        \"Internal error: can't get transaction by hash. Hash = \" + Common::podToHex(hash) + '.' };",
              "    }",
              "    blockHash = m_core.getBlockHashByIndex(blockHeight);",
              "    BlockTemplate blk = m_core.getBlockByHash(blockHash);",
              "    BlockDetails blkDetails = m_core.getBlockDetails(blockHash);",
              "",
              "    f_block_short_response block_short;",
              "",
              "    block_short.cumul_size = blkDetails.blockSize;",
              "    block_short.timestamp = blk.timestamp;",
              "    block_short.height = blockHeight;",
              "    block_short.hash = Common::podToHex(blockHash);",
              "    block_short.tx_count = blk.transactionHashes.size() + 1;",
              "    res.block = block_short;",
              "  }",
              "",
              "  uint64_t amount_in = getInputAmount(res.tx);",
              "  uint64_t amount_out = getOutputAmount(res.tx);",
              "",
              "  res.txDetails.hash = Common::podToHex(getObjectHash(res.tx));",
              "  res.txDetails.fee = amount_in - amount_out;",
              "  if (amount_in == 0)",
              "    res.txDetails.fee = 0;",
              "  res.txDetails.amount_out = amount_out;",
              "  res.txDetails.size = getObjectBinarySize(res.tx);",
              "",
              "  uint64_t mixin;",
              "  if (!f_getMixin(res.tx, mixin)) {",
              "    return false;",
              "  }",
              "  res.txDetails.mixin = mixin;",
              "",
              "  Crypto::Hash paymentId;",
              "  if (CryptoNote::getPaymentIdFromTxExtra(res.tx.extra, paymentId)) {",
              "    res.txDetails.paymentId = Common::podToHex(paymentId);",
              "  } else {",
              "    res.txDetails.paymentId = \"\";",
              "  }",
              "",
              "  res.status = CORE_RPC_STATUS_OK;",
              "  return true;",
              "}",
              "",

              "",
              "bool RpcServer::f_on_transactions_pool_json(const F_COMMAND_RPC_GET_POOL::request& req, F_COMMAND_RPC_GET_POOL::response& res) {",
              "  // check if blockchain explorer RPC is enabled",
              "  if (m_core.getCurrency().isBlockexplorer() == false) {",
              "    return false;",
              "  }",
              "",
              "  auto pool = m_core.getPoolTransactions();",
              "  for (const Transaction tx : pool) {",
              "    f_transaction_short_response transaction_short;",
              "    uint64_t amount_in = getInputAmount(tx);",
              "    uint64_t amount_out = getOutputAmount(tx);",
              "",
              "    transaction_short.hash = Common::podToHex(getObjectHash(tx));",
              "    transaction_short.fee = amount_in - amount_out;",
              "    transaction_short.amount_out = amount_out;",
              "    transaction_short.size = getObjectBinarySize(tx);",
              "    res.transactions.push_back(transaction_short);",
              "  }",
              "",
              "  res.status = CORE_RPC_STATUS_OK;",
              "  return true;",
              "}",
              "",

              "bool RpcServer::f_getMixin(const Transaction& transaction, uint64_t& mixin) {",
              "  mixin = 0;",
              "  for (const TransactionInput& txin : transaction.inputs) {",
              "    if (txin.type() != typeid(KeyInput)) {",
              "      continue;",
              "    }",
              "    uint64_t currentMixin = boost::get<KeyInput>(txin).outputIndexes.size();",
              "    if (currentMixin > mixin) {",
              "      mixin = currentMixin;",
              "    }",
              "  }",
              "  return true;",
              "}"
            ]
          }
        }
      ]
    }
  ]
}
